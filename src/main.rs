// Import required dependencies for CLI, cryptography, formatting and system operations
use clap::Parser;
use colored::*;
use ctrlc;
use ed25519_dalek::{SigningKey, VerifyingKey};
use humansize::{format_size, DECIMAL};
use regex::Regex;
use ssh_key::{LineEnding, PublicKey};
use std::fs;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::{Duration, Instant};

// Define command-line arguments structure using clap
#[derive(Parser)]
#[command(author, version, about)]
struct Args {
    // Pattern to match in generated SSH keys
    #[arg(short, long, help = "regex pattern goes here")]
    regex: String,

    // Enable case-insensitive matching
    #[arg(short, long, help = "case-insensitive")]
    insensitive: bool,

    // Continue generating keys after finding a match
    #[arg(short, long, help = "Keep processing keys, even after a match")]
    streaming: bool,

    // Match against key fingerprint instead of public key
    #[arg(short, long, help = "Match against fingerprint instead of public key")]
    fingerprint: bool,
}

// Global counter for tracking number of keys processed
static COUNTER: AtomicI64 = AtomicI64::new(0);

// Generate a new Ed25519 key pair
fn generate_key_pair() -> (SigningKey, VerifyingKey) {
    let mut rng = rand::thread_rng();
    let signing_key = SigningKey::generate(&mut rng);
    let verifying_key = signing_key.verifying_key();
    (signing_key, verifying_key)
}

// Convert public key to OpenSSH authorized_keys format
fn get_authorized_key(public_key: &VerifyingKey) -> String {
    let ssh_public_key = PublicKey::from_ed25519_key(public_key.as_bytes());
    ssh_public_key.to_string()
}

// Calculate SHA256 fingerprint of the public key
fn get_fingerprint(public_key: &VerifyingKey) -> String {
    use sha2::{Digest, Sha256};
    let mut hasher = Sha256::new();
    hasher.update(public_key.as_bytes());
    base64::encode(hasher.finalize())
}

// Core function to generate and match SSH keys against the regex pattern
fn find_ssh_keys(regex: &Regex, args: &Args, running: Arc<AtomicBool>) {
    while running.load(Ordering::SeqCst) {
        // Increment the global counter atomically
        COUNTER.fetch_add(1, Ordering::SeqCst);
        let (signing_key, verifying_key) = generate_key_pair();

        // Match against either fingerprint or public key based on args
        let matched = if args.fingerprint {
            regex.is_match(&get_fingerprint(&verifying_key))
        } else {
            regex.is_match(&get_authorized_key(&verifying_key))
        };

        if matched {
            println!("{}", "\nMatch found!".green());
            println!("Total keys processed: {}", COUNTER.load(Ordering::SeqCst));
            
            // Convert to OpenSSH private key format
            let private_key = ssh_key::PrivateKey::from_ed25519_key(
                signing_key.to_bytes().as_slice(),
                Some("Generated by SSHChic"),
            );
            
            let public_key_str = get_authorized_key(&verifying_key);
            println!("\nPrivate key:\n{}", private_key.to_string(LineEnding::LF));
            println!("Public key:\n{}", public_key_str);
            println!("Fingerprint: SHA256:{}", get_fingerprint(&verifying_key));

            // Save keys to files unless in streaming mode
            if !args.streaming {
                fs::write("id_ed25519", private_key.to_string(LineEnding::LF))
                    .expect("Failed to write private key");
                fs::write("id_ed25519.pub", public_key_str)
                    .expect("Failed to write public key");
                running.store(false, Ordering::SeqCst);
                break;
            }
        }
    }
}

// Calculate exponential moving average for key generation rate
fn exp_moving_average(value: f64, old_value: f64, delta_time: f64, time_window: f64) -> f64 {
    let alpha = 1.0 - (-delta_time / time_window).exp();
    alpha * value + (1.0 - alpha) * old_value
}

fn main() {
    // Parse command line arguments
    let args = Args::parse();
    let regex_str = if args.insensitive {
        format!("(?i){}", args.regex)
    } else {
        args.regex
    };

    // Compile regex pattern
    let regex = match Regex::new(&regex_str) {
        Ok(re) => re,
        Err(e) => {
            eprintln!("Invalid regex pattern: {}", e);
            std::process::exit(1);
        }
    };

    println!("Using regex pattern: {}", regex_str);
    let running = Arc::new(AtomicBool::new(true));
    let r = running.clone();

    // Set up Ctrl+C handler for graceful shutdown
    ctrlc::set_handler(move || {
        r.store(false, Ordering::SeqCst);
    })
    .expect("Error setting Ctrl-C handler");

    // Create worker threads based on CPU count
    let num_threads = num_cpus::get();
    let mut handles = vec![];

    for _ in 0..num_threads {
        let regex_clone = regex.clone();
        let args_clone = args.clone();
        let running_clone = running.clone();

        handles.push(thread::spawn(move || {
            find_ssh_keys(&regex_clone, &args_clone, running_clone);
        }));
    }

    println!("Press Ctrl+C to stop");

    // Initialize performance monitoring variables
    let mut old_counter = 0i64;
    let mut old_time = Instant::now();
    let mut avg_key_rate = 0f64;

    // Main monitoring loop
    while running.load(Ordering::SeqCst) {
        thread::sleep(Duration::from_millis(250));
        let current_counter = COUNTER.load(Ordering::SeqCst);
        let elapsed = old_time.elapsed().as_secs_f64();

        if old_counter == 0 {
            avg_key_rate = current_counter as f64;
        }

        // Update progress display
        print!("{}", "\x1B[2K\r");
        print!("Keys processed: {}", format_size(current_counter as u64, DECIMAL));
        print!(" | Rate: {:.2} kKeys/s", avg_key_rate / elapsed / 1000.0);

        // Calculate moving average of key generation rate
        avg_key_rate = exp_moving_average(
            (current_counter - old_counter) as f64,
            avg_key_rate,
            elapsed,
            5.0,
        );
        old_counter = current_counter;
        old_time = Instant::now();
    }

    // Wait for all worker threads to finish
    for handle in handles {
        handle.join().unwrap();
    }

    println!("\nDone!");
}